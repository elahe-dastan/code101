// Code generated by SQLBoiler 4.4.0 (https://github.com/volatiletech/sqlboiler). DO NOT EDIT.
// This file is meant to be re-generated in place and/or deleted at any time.

package models

import (
	"context"
	"database/sql"
	"fmt"
	"reflect"
	"strconv"
	"strings"
	"sync"
	"time"

	"github.com/friendsofgo/errors"
	"github.com/volatiletech/null/v8"
	"github.com/volatiletech/sqlboiler/v4/boil"
	"github.com/volatiletech/sqlboiler/v4/queries"
	"github.com/volatiletech/sqlboiler/v4/queries/qm"
	"github.com/volatiletech/sqlboiler/v4/queries/qmhelper"
	"github.com/volatiletech/strmangle"
)

// Passenger is an object representing the database table.
type Passenger struct {
	ID                        int         `boil:"id" json:"id" toml:"id" yaml:"id"`
	CreatedAt                 null.Time   `boil:"created_at" json:"created_at,omitempty" toml:"created_at" yaml:"created_at,omitempty"`
	UpdatedAt                 null.Time   `boil:"updated_at" json:"updated_at,omitempty" toml:"updated_at" yaml:"updated_at,omitempty"`
	Email                     null.String `boil:"email" json:"email,omitempty" toml:"email" yaml:"email,omitempty"`
	Password                  null.String `boil:"password" json:"password,omitempty" toml:"password" yaml:"password,omitempty"`
	Fullname                  null.String `boil:"fullname" json:"fullname,omitempty" toml:"fullname" yaml:"fullname,omitempty"`
	Phone                     null.String `boil:"phone" json:"phone,omitempty" toml:"phone" yaml:"phone,omitempty"`
	Cellphone                 null.String `boil:"cellphone" json:"cellphone,omitempty" toml:"cellphone" yaml:"cellphone,omitempty"`
	IsCellphoneVerified       bool        `boil:"is_cellphone_verified" json:"is_cellphone_verified" toml:"is_cellphone_verified" yaml:"is_cellphone_verified"`
	PhotoURL                  null.String `boil:"photo_url" json:"photo_url,omitempty" toml:"photo_url" yaml:"photo_url,omitempty"`
	IsEmailVerified           bool        `boil:"is_email_verified" json:"is_email_verified" toml:"is_email_verified" yaml:"is_email_verified"`
	Locale                    null.String `boil:"locale" json:"locale,omitempty" toml:"locale" yaml:"locale,omitempty"`
	ReferralCode              null.String `boil:"referral_code" json:"referral_code,omitempty" toml:"referral_code" yaml:"referral_code,omitempty"`
	RegisterationIP           null.String `boil:"registeration_ip" json:"registeration_ip,omitempty" toml:"registeration_ip" yaml:"registeration_ip,omitempty"`
	IsRegisteredWithGoogle    bool        `boil:"is_registered_with_google" json:"is_registered_with_google" toml:"is_registered_with_google" yaml:"is_registered_with_google"`
	EmailVerificationCode     string      `boil:"email_verification_code" json:"email_verification_code" toml:"email_verification_code" yaml:"email_verification_code"`
	CellphoneVerificationCode string      `boil:"cellphone_verification_code" json:"cellphone_verification_code" toml:"cellphone_verification_code" yaml:"cellphone_verification_code"`
	IsBlocked                 bool        `boil:"is_blocked" json:"is_blocked" toml:"is_blocked" yaml:"is_blocked"`
	AdjustFingerprint         string      `boil:"adjust_fingerprint" json:"adjust_fingerprint" toml:"adjust_fingerprint" yaml:"adjust_fingerprint"`
	ComapnyID                 int         `boil:"comapny_id" json:"comapny_id" toml:"comapny_id" yaml:"comapny_id"`

	R *passengerR `boil:"-" json:"-" toml:"-" yaml:"-"`
	L passengerL  `boil:"-" json:"-" toml:"-" yaml:"-"`
}

var PassengerColumns = struct {
	ID                        string
	CreatedAt                 string
	UpdatedAt                 string
	Email                     string
	Password                  string
	Fullname                  string
	Phone                     string
	Cellphone                 string
	IsCellphoneVerified       string
	PhotoURL                  string
	IsEmailVerified           string
	Locale                    string
	ReferralCode              string
	RegisterationIP           string
	IsRegisteredWithGoogle    string
	EmailVerificationCode     string
	CellphoneVerificationCode string
	IsBlocked                 string
	AdjustFingerprint         string
	ComapnyID                 string
}{
	ID:                        "id",
	CreatedAt:                 "created_at",
	UpdatedAt:                 "updated_at",
	Email:                     "email",
	Password:                  "password",
	Fullname:                  "fullname",
	Phone:                     "phone",
	Cellphone:                 "cellphone",
	IsCellphoneVerified:       "is_cellphone_verified",
	PhotoURL:                  "photo_url",
	IsEmailVerified:           "is_email_verified",
	Locale:                    "locale",
	ReferralCode:              "referral_code",
	RegisterationIP:           "registeration_ip",
	IsRegisteredWithGoogle:    "is_registered_with_google",
	EmailVerificationCode:     "email_verification_code",
	CellphoneVerificationCode: "cellphone_verification_code",
	IsBlocked:                 "is_blocked",
	AdjustFingerprint:         "adjust_fingerprint",
	ComapnyID:                 "comapny_id",
}

// Generated where

type whereHelperint struct{ field string }

func (w whereHelperint) EQ(x int) qm.QueryMod  { return qmhelper.Where(w.field, qmhelper.EQ, x) }
func (w whereHelperint) NEQ(x int) qm.QueryMod { return qmhelper.Where(w.field, qmhelper.NEQ, x) }
func (w whereHelperint) LT(x int) qm.QueryMod  { return qmhelper.Where(w.field, qmhelper.LT, x) }
func (w whereHelperint) LTE(x int) qm.QueryMod { return qmhelper.Where(w.field, qmhelper.LTE, x) }
func (w whereHelperint) GT(x int) qm.QueryMod  { return qmhelper.Where(w.field, qmhelper.GT, x) }
func (w whereHelperint) GTE(x int) qm.QueryMod { return qmhelper.Where(w.field, qmhelper.GTE, x) }
func (w whereHelperint) IN(slice []int) qm.QueryMod {
	values := make([]interface{}, 0, len(slice))
	for _, value := range slice {
		values = append(values, value)
	}
	return qm.WhereIn(fmt.Sprintf("%s IN ?", w.field), values...)
}
func (w whereHelperint) NIN(slice []int) qm.QueryMod {
	values := make([]interface{}, 0, len(slice))
	for _, value := range slice {
		values = append(values, value)
	}
	return qm.WhereNotIn(fmt.Sprintf("%s NOT IN ?", w.field), values...)
}

type whereHelpernull_Time struct{ field string }

func (w whereHelpernull_Time) EQ(x null.Time) qm.QueryMod {
	return qmhelper.WhereNullEQ(w.field, false, x)
}
func (w whereHelpernull_Time) NEQ(x null.Time) qm.QueryMod {
	return qmhelper.WhereNullEQ(w.field, true, x)
}
func (w whereHelpernull_Time) IsNull() qm.QueryMod    { return qmhelper.WhereIsNull(w.field) }
func (w whereHelpernull_Time) IsNotNull() qm.QueryMod { return qmhelper.WhereIsNotNull(w.field) }
func (w whereHelpernull_Time) LT(x null.Time) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.LT, x)
}
func (w whereHelpernull_Time) LTE(x null.Time) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.LTE, x)
}
func (w whereHelpernull_Time) GT(x null.Time) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.GT, x)
}
func (w whereHelpernull_Time) GTE(x null.Time) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.GTE, x)
}

type whereHelpernull_String struct{ field string }

func (w whereHelpernull_String) EQ(x null.String) qm.QueryMod {
	return qmhelper.WhereNullEQ(w.field, false, x)
}
func (w whereHelpernull_String) NEQ(x null.String) qm.QueryMod {
	return qmhelper.WhereNullEQ(w.field, true, x)
}
func (w whereHelpernull_String) IsNull() qm.QueryMod    { return qmhelper.WhereIsNull(w.field) }
func (w whereHelpernull_String) IsNotNull() qm.QueryMod { return qmhelper.WhereIsNotNull(w.field) }
func (w whereHelpernull_String) LT(x null.String) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.LT, x)
}
func (w whereHelpernull_String) LTE(x null.String) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.LTE, x)
}
func (w whereHelpernull_String) GT(x null.String) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.GT, x)
}
func (w whereHelpernull_String) GTE(x null.String) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.GTE, x)
}

type whereHelperbool struct{ field string }

func (w whereHelperbool) EQ(x bool) qm.QueryMod  { return qmhelper.Where(w.field, qmhelper.EQ, x) }
func (w whereHelperbool) NEQ(x bool) qm.QueryMod { return qmhelper.Where(w.field, qmhelper.NEQ, x) }
func (w whereHelperbool) LT(x bool) qm.QueryMod  { return qmhelper.Where(w.field, qmhelper.LT, x) }
func (w whereHelperbool) LTE(x bool) qm.QueryMod { return qmhelper.Where(w.field, qmhelper.LTE, x) }
func (w whereHelperbool) GT(x bool) qm.QueryMod  { return qmhelper.Where(w.field, qmhelper.GT, x) }
func (w whereHelperbool) GTE(x bool) qm.QueryMod { return qmhelper.Where(w.field, qmhelper.GTE, x) }

type whereHelperstring struct{ field string }

func (w whereHelperstring) EQ(x string) qm.QueryMod  { return qmhelper.Where(w.field, qmhelper.EQ, x) }
func (w whereHelperstring) NEQ(x string) qm.QueryMod { return qmhelper.Where(w.field, qmhelper.NEQ, x) }
func (w whereHelperstring) LT(x string) qm.QueryMod  { return qmhelper.Where(w.field, qmhelper.LT, x) }
func (w whereHelperstring) LTE(x string) qm.QueryMod { return qmhelper.Where(w.field, qmhelper.LTE, x) }
func (w whereHelperstring) GT(x string) qm.QueryMod  { return qmhelper.Where(w.field, qmhelper.GT, x) }
func (w whereHelperstring) GTE(x string) qm.QueryMod { return qmhelper.Where(w.field, qmhelper.GTE, x) }
func (w whereHelperstring) IN(slice []string) qm.QueryMod {
	values := make([]interface{}, 0, len(slice))
	for _, value := range slice {
		values = append(values, value)
	}
	return qm.WhereIn(fmt.Sprintf("%s IN ?", w.field), values...)
}
func (w whereHelperstring) NIN(slice []string) qm.QueryMod {
	values := make([]interface{}, 0, len(slice))
	for _, value := range slice {
		values = append(values, value)
	}
	return qm.WhereNotIn(fmt.Sprintf("%s NOT IN ?", w.field), values...)
}

var PassengerWhere = struct {
	ID                        whereHelperint
	CreatedAt                 whereHelpernull_Time
	UpdatedAt                 whereHelpernull_Time
	Email                     whereHelpernull_String
	Password                  whereHelpernull_String
	Fullname                  whereHelpernull_String
	Phone                     whereHelpernull_String
	Cellphone                 whereHelpernull_String
	IsCellphoneVerified       whereHelperbool
	PhotoURL                  whereHelpernull_String
	IsEmailVerified           whereHelperbool
	Locale                    whereHelpernull_String
	ReferralCode              whereHelpernull_String
	RegisterationIP           whereHelpernull_String
	IsRegisteredWithGoogle    whereHelperbool
	EmailVerificationCode     whereHelperstring
	CellphoneVerificationCode whereHelperstring
	IsBlocked                 whereHelperbool
	AdjustFingerprint         whereHelperstring
	ComapnyID                 whereHelperint
}{
	ID:                        whereHelperint{field: "`passenger`.`id`"},
	CreatedAt:                 whereHelpernull_Time{field: "`passenger`.`created_at`"},
	UpdatedAt:                 whereHelpernull_Time{field: "`passenger`.`updated_at`"},
	Email:                     whereHelpernull_String{field: "`passenger`.`email`"},
	Password:                  whereHelpernull_String{field: "`passenger`.`password`"},
	Fullname:                  whereHelpernull_String{field: "`passenger`.`fullname`"},
	Phone:                     whereHelpernull_String{field: "`passenger`.`phone`"},
	Cellphone:                 whereHelpernull_String{field: "`passenger`.`cellphone`"},
	IsCellphoneVerified:       whereHelperbool{field: "`passenger`.`is_cellphone_verified`"},
	PhotoURL:                  whereHelpernull_String{field: "`passenger`.`photo_url`"},
	IsEmailVerified:           whereHelperbool{field: "`passenger`.`is_email_verified`"},
	Locale:                    whereHelpernull_String{field: "`passenger`.`locale`"},
	ReferralCode:              whereHelpernull_String{field: "`passenger`.`referral_code`"},
	RegisterationIP:           whereHelpernull_String{field: "`passenger`.`registeration_ip`"},
	IsRegisteredWithGoogle:    whereHelperbool{field: "`passenger`.`is_registered_with_google`"},
	EmailVerificationCode:     whereHelperstring{field: "`passenger`.`email_verification_code`"},
	CellphoneVerificationCode: whereHelperstring{field: "`passenger`.`cellphone_verification_code`"},
	IsBlocked:                 whereHelperbool{field: "`passenger`.`is_blocked`"},
	AdjustFingerprint:         whereHelperstring{field: "`passenger`.`adjust_fingerprint`"},
	ComapnyID:                 whereHelperint{field: "`passenger`.`comapny_id`"},
}

// PassengerRels is where relationship names are stored.
var PassengerRels = struct {
	Rides string
}{
	Rides: "Rides",
}

// passengerR is where relationships are stored.
type passengerR struct {
	Rides RideSlice `boil:"Rides" json:"Rides" toml:"Rides" yaml:"Rides"`
}

// NewStruct creates a new relationship struct
func (*passengerR) NewStruct() *passengerR {
	return &passengerR{}
}

// passengerL is where Load methods for each relationship are stored.
type passengerL struct{}

var (
	passengerAllColumns            = []string{"id", "created_at", "updated_at", "email", "password", "fullname", "phone", "cellphone", "is_cellphone_verified", "photo_url", "is_email_verified", "locale", "referral_code", "registeration_ip", "is_registered_with_google", "email_verification_code", "cellphone_verification_code", "is_blocked", "adjust_fingerprint", "comapny_id"}
	passengerColumnsWithoutDefault = []string{"id", "created_at", "updated_at", "email", "password", "fullname", "phone", "cellphone", "is_cellphone_verified", "photo_url", "is_email_verified", "locale", "referral_code", "registeration_ip", "is_registered_with_google", "email_verification_code", "cellphone_verification_code", "is_blocked", "adjust_fingerprint", "comapny_id"}
	passengerColumnsWithDefault    = []string{}
	passengerPrimaryKeyColumns     = []string{"id"}
)

type (
	// PassengerSlice is an alias for a slice of pointers to Passenger.
	// This should generally be used opposed to []Passenger.
	PassengerSlice []*Passenger
	// PassengerHook is the signature for custom Passenger hook methods
	PassengerHook func(context.Context, boil.ContextExecutor, *Passenger) error

	passengerQuery struct {
		*queries.Query
	}
)

// Cache for insert, update and upsert
var (
	passengerType                 = reflect.TypeOf(&Passenger{})
	passengerMapping              = queries.MakeStructMapping(passengerType)
	passengerPrimaryKeyMapping, _ = queries.BindMapping(passengerType, passengerMapping, passengerPrimaryKeyColumns)
	passengerInsertCacheMut       sync.RWMutex
	passengerInsertCache          = make(map[string]insertCache)
	passengerUpdateCacheMut       sync.RWMutex
	passengerUpdateCache          = make(map[string]updateCache)
	passengerUpsertCacheMut       sync.RWMutex
	passengerUpsertCache          = make(map[string]insertCache)
)

var (
	// Force time package dependency for automated UpdatedAt/CreatedAt.
	_ = time.Second
	// Force qmhelper dependency for where clause generation (which doesn't
	// always happen)
	_ = qmhelper.Where
)

var passengerBeforeInsertHooks []PassengerHook
var passengerBeforeUpdateHooks []PassengerHook
var passengerBeforeDeleteHooks []PassengerHook
var passengerBeforeUpsertHooks []PassengerHook

var passengerAfterInsertHooks []PassengerHook
var passengerAfterSelectHooks []PassengerHook
var passengerAfterUpdateHooks []PassengerHook
var passengerAfterDeleteHooks []PassengerHook
var passengerAfterUpsertHooks []PassengerHook

// doBeforeInsertHooks executes all "before insert" hooks.
func (o *Passenger) doBeforeInsertHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range passengerBeforeInsertHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doBeforeUpdateHooks executes all "before Update" hooks.
func (o *Passenger) doBeforeUpdateHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range passengerBeforeUpdateHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doBeforeDeleteHooks executes all "before Delete" hooks.
func (o *Passenger) doBeforeDeleteHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range passengerBeforeDeleteHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doBeforeUpsertHooks executes all "before Upsert" hooks.
func (o *Passenger) doBeforeUpsertHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range passengerBeforeUpsertHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterInsertHooks executes all "after Insert" hooks.
func (o *Passenger) doAfterInsertHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range passengerAfterInsertHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterSelectHooks executes all "after Select" hooks.
func (o *Passenger) doAfterSelectHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range passengerAfterSelectHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterUpdateHooks executes all "after Update" hooks.
func (o *Passenger) doAfterUpdateHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range passengerAfterUpdateHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterDeleteHooks executes all "after Delete" hooks.
func (o *Passenger) doAfterDeleteHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range passengerAfterDeleteHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterUpsertHooks executes all "after Upsert" hooks.
func (o *Passenger) doAfterUpsertHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range passengerAfterUpsertHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// AddPassengerHook registers your hook function for all future operations.
func AddPassengerHook(hookPoint boil.HookPoint, passengerHook PassengerHook) {
	switch hookPoint {
	case boil.BeforeInsertHook:
		passengerBeforeInsertHooks = append(passengerBeforeInsertHooks, passengerHook)
	case boil.BeforeUpdateHook:
		passengerBeforeUpdateHooks = append(passengerBeforeUpdateHooks, passengerHook)
	case boil.BeforeDeleteHook:
		passengerBeforeDeleteHooks = append(passengerBeforeDeleteHooks, passengerHook)
	case boil.BeforeUpsertHook:
		passengerBeforeUpsertHooks = append(passengerBeforeUpsertHooks, passengerHook)
	case boil.AfterInsertHook:
		passengerAfterInsertHooks = append(passengerAfterInsertHooks, passengerHook)
	case boil.AfterSelectHook:
		passengerAfterSelectHooks = append(passengerAfterSelectHooks, passengerHook)
	case boil.AfterUpdateHook:
		passengerAfterUpdateHooks = append(passengerAfterUpdateHooks, passengerHook)
	case boil.AfterDeleteHook:
		passengerAfterDeleteHooks = append(passengerAfterDeleteHooks, passengerHook)
	case boil.AfterUpsertHook:
		passengerAfterUpsertHooks = append(passengerAfterUpsertHooks, passengerHook)
	}
}

// One returns a single passenger record from the query.
func (q passengerQuery) One(ctx context.Context, exec boil.ContextExecutor) (*Passenger, error) {
	o := &Passenger{}

	queries.SetLimit(q.Query, 1)

	err := q.Bind(ctx, exec, o)
	if err != nil {
		if errors.Cause(err) == sql.ErrNoRows {
			return nil, sql.ErrNoRows
		}
		return nil, errors.Wrap(err, "models: failed to execute a one query for passenger")
	}

	if err := o.doAfterSelectHooks(ctx, exec); err != nil {
		return o, err
	}

	return o, nil
}

// All returns all Passenger records from the query.
func (q passengerQuery) All(ctx context.Context, exec boil.ContextExecutor) (PassengerSlice, error) {
	var o []*Passenger

	err := q.Bind(ctx, exec, &o)
	if err != nil {
		return nil, errors.Wrap(err, "models: failed to assign all query results to Passenger slice")
	}

	if len(passengerAfterSelectHooks) != 0 {
		for _, obj := range o {
			if err := obj.doAfterSelectHooks(ctx, exec); err != nil {
				return o, err
			}
		}
	}

	return o, nil
}

// Count returns the count of all Passenger records in the query.
func (q passengerQuery) Count(ctx context.Context, exec boil.ContextExecutor) (int64, error) {
	var count int64

	queries.SetSelect(q.Query, nil)
	queries.SetCount(q.Query)

	err := q.Query.QueryRowContext(ctx, exec).Scan(&count)
	if err != nil {
		return 0, errors.Wrap(err, "models: failed to count passenger rows")
	}

	return count, nil
}

// Exists checks if the row exists in the table.
func (q passengerQuery) Exists(ctx context.Context, exec boil.ContextExecutor) (bool, error) {
	var count int64

	queries.SetSelect(q.Query, nil)
	queries.SetCount(q.Query)
	queries.SetLimit(q.Query, 1)

	err := q.Query.QueryRowContext(ctx, exec).Scan(&count)
	if err != nil {
		return false, errors.Wrap(err, "models: failed to check if passenger exists")
	}

	return count > 0, nil
}

// Rides retrieves all the ride's Rides with an executor.
func (o *Passenger) Rides(mods ...qm.QueryMod) rideQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("`ride`.`passenger_id`=?", o.ID),
	)

	query := Rides(queryMods...)
	queries.SetFrom(query.Query, "`ride`")

	if len(queries.GetSelect(query.Query)) == 0 {
		queries.SetSelect(query.Query, []string{"`ride`.*"})
	}

	return query
}

// LoadRides allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (passengerL) LoadRides(ctx context.Context, e boil.ContextExecutor, singular bool, maybePassenger interface{}, mods queries.Applicator) error {
	var slice []*Passenger
	var object *Passenger

	if singular {
		object = maybePassenger.(*Passenger)
	} else {
		slice = *maybePassenger.(*[]*Passenger)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &passengerR{}
		}
		args = append(args, object.ID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &passengerR{}
			}

			for _, a := range args {
				if queries.Equal(a, obj.ID) {
					continue Outer
				}
			}

			args = append(args, obj.ID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`ride`),
		qm.WhereIn(`ride.passenger_id in ?`, args...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load ride")
	}

	var resultSlice []*Ride
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice ride")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on ride")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for ride")
	}

	if len(rideAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.Rides = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &rideR{}
			}
			foreign.R.Passenger = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if queries.Equal(local.ID, foreign.PassengerID) {
				local.R.Rides = append(local.R.Rides, foreign)
				if foreign.R == nil {
					foreign.R = &rideR{}
				}
				foreign.R.Passenger = local
				break
			}
		}
	}

	return nil
}

// AddRides adds the given related objects to the existing relationships
// of the passenger, optionally inserting them as new records.
// Appends related to o.R.Rides.
// Sets related.R.Passenger appropriately.
func (o *Passenger) AddRides(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*Ride) error {
	var err error
	for _, rel := range related {
		if insert {
			queries.Assign(&rel.PassengerID, o.ID)
			if err = rel.Insert(ctx, exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE `ride` SET %s WHERE %s",
				strmangle.SetParamNames("`", "`", 0, []string{"passenger_id"}),
				strmangle.WhereClause("`", "`", 0, ridePrimaryKeyColumns),
			)
			values := []interface{}{o.ID, rel.ID}

			if boil.IsDebug(ctx) {
				writer := boil.DebugWriterFrom(ctx)
				fmt.Fprintln(writer, updateQuery)
				fmt.Fprintln(writer, values)
			}
			if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			queries.Assign(&rel.PassengerID, o.ID)
		}
	}

	if o.R == nil {
		o.R = &passengerR{
			Rides: related,
		}
	} else {
		o.R.Rides = append(o.R.Rides, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &rideR{
				Passenger: o,
			}
		} else {
			rel.R.Passenger = o
		}
	}
	return nil
}

// SetRides removes all previously related items of the
// passenger replacing them completely with the passed
// in related items, optionally inserting them as new records.
// Sets o.R.Passenger's Rides accordingly.
// Replaces o.R.Rides with related.
// Sets related.R.Passenger's Rides accordingly.
func (o *Passenger) SetRides(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*Ride) error {
	query := "update `ride` set `passenger_id` = null where `passenger_id` = ?"
	values := []interface{}{o.ID}
	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, query)
		fmt.Fprintln(writer, values)
	}
	_, err := exec.ExecContext(ctx, query, values...)
	if err != nil {
		return errors.Wrap(err, "failed to remove relationships before set")
	}

	if o.R != nil {
		for _, rel := range o.R.Rides {
			queries.SetScanner(&rel.PassengerID, nil)
			if rel.R == nil {
				continue
			}

			rel.R.Passenger = nil
		}

		o.R.Rides = nil
	}
	return o.AddRides(ctx, exec, insert, related...)
}

// RemoveRides relationships from objects passed in.
// Removes related items from R.Rides (uses pointer comparison, removal does not keep order)
// Sets related.R.Passenger.
func (o *Passenger) RemoveRides(ctx context.Context, exec boil.ContextExecutor, related ...*Ride) error {
	var err error
	for _, rel := range related {
		queries.SetScanner(&rel.PassengerID, nil)
		if rel.R != nil {
			rel.R.Passenger = nil
		}
		if _, err = rel.Update(ctx, exec, boil.Whitelist("passenger_id")); err != nil {
			return err
		}
	}
	if o.R == nil {
		return nil
	}

	for _, rel := range related {
		for i, ri := range o.R.Rides {
			if rel != ri {
				continue
			}

			ln := len(o.R.Rides)
			if ln > 1 && i < ln-1 {
				o.R.Rides[i] = o.R.Rides[ln-1]
			}
			o.R.Rides = o.R.Rides[:ln-1]
			break
		}
	}

	return nil
}

// Passengers retrieves all the records using an executor.
func Passengers(mods ...qm.QueryMod) passengerQuery {
	mods = append(mods, qm.From("`passenger`"))
	return passengerQuery{NewQuery(mods...)}
}

// FindPassenger retrieves a single record by ID with an executor.
// If selectCols is empty Find will return all columns.
func FindPassenger(ctx context.Context, exec boil.ContextExecutor, iD int, selectCols ...string) (*Passenger, error) {
	passengerObj := &Passenger{}

	sel := "*"
	if len(selectCols) > 0 {
		sel = strings.Join(strmangle.IdentQuoteSlice(dialect.LQ, dialect.RQ, selectCols), ",")
	}
	query := fmt.Sprintf(
		"select %s from `passenger` where `id`=?", sel,
	)

	q := queries.Raw(query, iD)

	err := q.Bind(ctx, exec, passengerObj)
	if err != nil {
		if errors.Cause(err) == sql.ErrNoRows {
			return nil, sql.ErrNoRows
		}
		return nil, errors.Wrap(err, "models: unable to select from passenger")
	}

	return passengerObj, nil
}

// Insert a single record using an executor.
// See boil.Columns.InsertColumnSet documentation to understand column list inference for inserts.
func (o *Passenger) Insert(ctx context.Context, exec boil.ContextExecutor, columns boil.Columns) error {
	if o == nil {
		return errors.New("models: no passenger provided for insertion")
	}

	var err error
	if !boil.TimestampsAreSkipped(ctx) {
		currTime := time.Now().In(boil.GetLocation())

		if queries.MustTime(o.CreatedAt).IsZero() {
			queries.SetScanner(&o.CreatedAt, currTime)
		}
		if queries.MustTime(o.UpdatedAt).IsZero() {
			queries.SetScanner(&o.UpdatedAt, currTime)
		}
	}

	if err := o.doBeforeInsertHooks(ctx, exec); err != nil {
		return err
	}

	nzDefaults := queries.NonZeroDefaultSet(passengerColumnsWithDefault, o)

	key := makeCacheKey(columns, nzDefaults)
	passengerInsertCacheMut.RLock()
	cache, cached := passengerInsertCache[key]
	passengerInsertCacheMut.RUnlock()

	if !cached {
		wl, returnColumns := columns.InsertColumnSet(
			passengerAllColumns,
			passengerColumnsWithDefault,
			passengerColumnsWithoutDefault,
			nzDefaults,
		)

		cache.valueMapping, err = queries.BindMapping(passengerType, passengerMapping, wl)
		if err != nil {
			return err
		}
		cache.retMapping, err = queries.BindMapping(passengerType, passengerMapping, returnColumns)
		if err != nil {
			return err
		}
		if len(wl) != 0 {
			cache.query = fmt.Sprintf("INSERT INTO `passenger` (`%s`) %%sVALUES (%s)%%s", strings.Join(wl, "`,`"), strmangle.Placeholders(dialect.UseIndexPlaceholders, len(wl), 1, 1))
		} else {
			cache.query = "INSERT INTO `passenger` () VALUES ()%s%s"
		}

		var queryOutput, queryReturning string

		if len(cache.retMapping) != 0 {
			cache.retQuery = fmt.Sprintf("SELECT `%s` FROM `passenger` WHERE %s", strings.Join(returnColumns, "`,`"), strmangle.WhereClause("`", "`", 0, passengerPrimaryKeyColumns))
		}

		cache.query = fmt.Sprintf(cache.query, queryOutput, queryReturning)
	}

	value := reflect.Indirect(reflect.ValueOf(o))
	vals := queries.ValuesFromMapping(value, cache.valueMapping)

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, cache.query)
		fmt.Fprintln(writer, vals)
	}
	_, err = exec.ExecContext(ctx, cache.query, vals...)

	if err != nil {
		return errors.Wrap(err, "models: unable to insert into passenger")
	}

	var identifierCols []interface{}

	if len(cache.retMapping) == 0 {
		goto CacheNoHooks
	}

	identifierCols = []interface{}{
		o.ID,
	}

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, cache.retQuery)
		fmt.Fprintln(writer, identifierCols...)
	}
	err = exec.QueryRowContext(ctx, cache.retQuery, identifierCols...).Scan(queries.PtrsFromMapping(value, cache.retMapping)...)
	if err != nil {
		return errors.Wrap(err, "models: unable to populate default values for passenger")
	}

CacheNoHooks:
	if !cached {
		passengerInsertCacheMut.Lock()
		passengerInsertCache[key] = cache
		passengerInsertCacheMut.Unlock()
	}

	return o.doAfterInsertHooks(ctx, exec)
}

// Update uses an executor to update the Passenger.
// See boil.Columns.UpdateColumnSet documentation to understand column list inference for updates.
// Update does not automatically update the record in case of default values. Use .Reload() to refresh the records.
func (o *Passenger) Update(ctx context.Context, exec boil.ContextExecutor, columns boil.Columns) (int64, error) {
	if !boil.TimestampsAreSkipped(ctx) {
		currTime := time.Now().In(boil.GetLocation())

		queries.SetScanner(&o.UpdatedAt, currTime)
	}

	var err error
	if err = o.doBeforeUpdateHooks(ctx, exec); err != nil {
		return 0, err
	}
	key := makeCacheKey(columns, nil)
	passengerUpdateCacheMut.RLock()
	cache, cached := passengerUpdateCache[key]
	passengerUpdateCacheMut.RUnlock()

	if !cached {
		wl := columns.UpdateColumnSet(
			passengerAllColumns,
			passengerPrimaryKeyColumns,
		)

		if !columns.IsWhitelist() {
			wl = strmangle.SetComplement(wl, []string{"created_at"})
		}
		if len(wl) == 0 {
			return 0, errors.New("models: unable to update passenger, could not build whitelist")
		}

		cache.query = fmt.Sprintf("UPDATE `passenger` SET %s WHERE %s",
			strmangle.SetParamNames("`", "`", 0, wl),
			strmangle.WhereClause("`", "`", 0, passengerPrimaryKeyColumns),
		)
		cache.valueMapping, err = queries.BindMapping(passengerType, passengerMapping, append(wl, passengerPrimaryKeyColumns...))
		if err != nil {
			return 0, err
		}
	}

	values := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(o)), cache.valueMapping)

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, cache.query)
		fmt.Fprintln(writer, values)
	}
	var result sql.Result
	result, err = exec.ExecContext(ctx, cache.query, values...)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to update passenger row")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: failed to get rows affected by update for passenger")
	}

	if !cached {
		passengerUpdateCacheMut.Lock()
		passengerUpdateCache[key] = cache
		passengerUpdateCacheMut.Unlock()
	}

	return rowsAff, o.doAfterUpdateHooks(ctx, exec)
}

// UpdateAll updates all rows with the specified column values.
func (q passengerQuery) UpdateAll(ctx context.Context, exec boil.ContextExecutor, cols M) (int64, error) {
	queries.SetUpdate(q.Query, cols)

	result, err := q.Query.ExecContext(ctx, exec)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to update all for passenger")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to retrieve rows affected for passenger")
	}

	return rowsAff, nil
}

// UpdateAll updates all rows with the specified column values, using an executor.
func (o PassengerSlice) UpdateAll(ctx context.Context, exec boil.ContextExecutor, cols M) (int64, error) {
	ln := int64(len(o))
	if ln == 0 {
		return 0, nil
	}

	if len(cols) == 0 {
		return 0, errors.New("models: update all requires at least one column argument")
	}

	colNames := make([]string, len(cols))
	args := make([]interface{}, len(cols))

	i := 0
	for name, value := range cols {
		colNames[i] = name
		args[i] = value
		i++
	}

	// Append all of the primary key values for each column
	for _, obj := range o {
		pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), passengerPrimaryKeyMapping)
		args = append(args, pkeyArgs...)
	}

	sql := fmt.Sprintf("UPDATE `passenger` SET %s WHERE %s",
		strmangle.SetParamNames("`", "`", 0, colNames),
		strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), 0, passengerPrimaryKeyColumns, len(o)))

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, sql)
		fmt.Fprintln(writer, args...)
	}
	result, err := exec.ExecContext(ctx, sql, args...)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to update all in passenger slice")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to retrieve rows affected all in update all passenger")
	}
	return rowsAff, nil
}

var mySQLPassengerUniqueColumns = []string{
	"id",
}

// Upsert attempts an insert using an executor, and does an update or ignore on conflict.
// See boil.Columns documentation for how to properly use updateColumns and insertColumns.
func (o *Passenger) Upsert(ctx context.Context, exec boil.ContextExecutor, updateColumns, insertColumns boil.Columns) error {
	if o == nil {
		return errors.New("models: no passenger provided for upsert")
	}
	if !boil.TimestampsAreSkipped(ctx) {
		currTime := time.Now().In(boil.GetLocation())

		if queries.MustTime(o.CreatedAt).IsZero() {
			queries.SetScanner(&o.CreatedAt, currTime)
		}
		queries.SetScanner(&o.UpdatedAt, currTime)
	}

	if err := o.doBeforeUpsertHooks(ctx, exec); err != nil {
		return err
	}

	nzDefaults := queries.NonZeroDefaultSet(passengerColumnsWithDefault, o)
	nzUniques := queries.NonZeroDefaultSet(mySQLPassengerUniqueColumns, o)

	if len(nzUniques) == 0 {
		return errors.New("cannot upsert with a table that cannot conflict on a unique column")
	}

	// Build cache key in-line uglily - mysql vs psql problems
	buf := strmangle.GetBuffer()
	buf.WriteString(strconv.Itoa(updateColumns.Kind))
	for _, c := range updateColumns.Cols {
		buf.WriteString(c)
	}
	buf.WriteByte('.')
	buf.WriteString(strconv.Itoa(insertColumns.Kind))
	for _, c := range insertColumns.Cols {
		buf.WriteString(c)
	}
	buf.WriteByte('.')
	for _, c := range nzDefaults {
		buf.WriteString(c)
	}
	buf.WriteByte('.')
	for _, c := range nzUniques {
		buf.WriteString(c)
	}
	key := buf.String()
	strmangle.PutBuffer(buf)

	passengerUpsertCacheMut.RLock()
	cache, cached := passengerUpsertCache[key]
	passengerUpsertCacheMut.RUnlock()

	var err error

	if !cached {
		insert, ret := insertColumns.InsertColumnSet(
			passengerAllColumns,
			passengerColumnsWithDefault,
			passengerColumnsWithoutDefault,
			nzDefaults,
		)
		update := updateColumns.UpdateColumnSet(
			passengerAllColumns,
			passengerPrimaryKeyColumns,
		)

		if !updateColumns.IsNone() && len(update) == 0 {
			return errors.New("models: unable to upsert passenger, could not build update column list")
		}

		ret = strmangle.SetComplement(ret, nzUniques)
		cache.query = buildUpsertQueryMySQL(dialect, "`passenger`", update, insert)
		cache.retQuery = fmt.Sprintf(
			"SELECT %s FROM `passenger` WHERE %s",
			strings.Join(strmangle.IdentQuoteSlice(dialect.LQ, dialect.RQ, ret), ","),
			strmangle.WhereClause("`", "`", 0, nzUniques),
		)

		cache.valueMapping, err = queries.BindMapping(passengerType, passengerMapping, insert)
		if err != nil {
			return err
		}
		if len(ret) != 0 {
			cache.retMapping, err = queries.BindMapping(passengerType, passengerMapping, ret)
			if err != nil {
				return err
			}
		}
	}

	value := reflect.Indirect(reflect.ValueOf(o))
	vals := queries.ValuesFromMapping(value, cache.valueMapping)
	var returns []interface{}
	if len(cache.retMapping) != 0 {
		returns = queries.PtrsFromMapping(value, cache.retMapping)
	}

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, cache.query)
		fmt.Fprintln(writer, vals)
	}
	_, err = exec.ExecContext(ctx, cache.query, vals...)

	if err != nil {
		return errors.Wrap(err, "models: unable to upsert for passenger")
	}

	var uniqueMap []uint64
	var nzUniqueCols []interface{}

	if len(cache.retMapping) == 0 {
		goto CacheNoHooks
	}

	uniqueMap, err = queries.BindMapping(passengerType, passengerMapping, nzUniques)
	if err != nil {
		return errors.Wrap(err, "models: unable to retrieve unique values for passenger")
	}
	nzUniqueCols = queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(o)), uniqueMap)

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, cache.retQuery)
		fmt.Fprintln(writer, nzUniqueCols...)
	}
	err = exec.QueryRowContext(ctx, cache.retQuery, nzUniqueCols...).Scan(returns...)
	if err != nil {
		return errors.Wrap(err, "models: unable to populate default values for passenger")
	}

CacheNoHooks:
	if !cached {
		passengerUpsertCacheMut.Lock()
		passengerUpsertCache[key] = cache
		passengerUpsertCacheMut.Unlock()
	}

	return o.doAfterUpsertHooks(ctx, exec)
}

// Delete deletes a single Passenger record with an executor.
// Delete will match against the primary key column to find the record to delete.
func (o *Passenger) Delete(ctx context.Context, exec boil.ContextExecutor) (int64, error) {
	if o == nil {
		return 0, errors.New("models: no Passenger provided for delete")
	}

	if err := o.doBeforeDeleteHooks(ctx, exec); err != nil {
		return 0, err
	}

	args := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(o)), passengerPrimaryKeyMapping)
	sql := "DELETE FROM `passenger` WHERE `id`=?"

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, sql)
		fmt.Fprintln(writer, args...)
	}
	result, err := exec.ExecContext(ctx, sql, args...)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to delete from passenger")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: failed to get rows affected by delete for passenger")
	}

	if err := o.doAfterDeleteHooks(ctx, exec); err != nil {
		return 0, err
	}

	return rowsAff, nil
}

// DeleteAll deletes all matching rows.
func (q passengerQuery) DeleteAll(ctx context.Context, exec boil.ContextExecutor) (int64, error) {
	if q.Query == nil {
		return 0, errors.New("models: no passengerQuery provided for delete all")
	}

	queries.SetDelete(q.Query)

	result, err := q.Query.ExecContext(ctx, exec)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to delete all from passenger")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: failed to get rows affected by deleteall for passenger")
	}

	return rowsAff, nil
}

// DeleteAll deletes all rows in the slice, using an executor.
func (o PassengerSlice) DeleteAll(ctx context.Context, exec boil.ContextExecutor) (int64, error) {
	if len(o) == 0 {
		return 0, nil
	}

	if len(passengerBeforeDeleteHooks) != 0 {
		for _, obj := range o {
			if err := obj.doBeforeDeleteHooks(ctx, exec); err != nil {
				return 0, err
			}
		}
	}

	var args []interface{}
	for _, obj := range o {
		pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), passengerPrimaryKeyMapping)
		args = append(args, pkeyArgs...)
	}

	sql := "DELETE FROM `passenger` WHERE " +
		strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), 0, passengerPrimaryKeyColumns, len(o))

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, sql)
		fmt.Fprintln(writer, args)
	}
	result, err := exec.ExecContext(ctx, sql, args...)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to delete all from passenger slice")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: failed to get rows affected by deleteall for passenger")
	}

	if len(passengerAfterDeleteHooks) != 0 {
		for _, obj := range o {
			if err := obj.doAfterDeleteHooks(ctx, exec); err != nil {
				return 0, err
			}
		}
	}

	return rowsAff, nil
}

// Reload refetches the object from the database
// using the primary keys with an executor.
func (o *Passenger) Reload(ctx context.Context, exec boil.ContextExecutor) error {
	ret, err := FindPassenger(ctx, exec, o.ID)
	if err != nil {
		return err
	}

	*o = *ret
	return nil
}

// ReloadAll refetches every row with matching primary key column values
// and overwrites the original object slice with the newly updated slice.
func (o *PassengerSlice) ReloadAll(ctx context.Context, exec boil.ContextExecutor) error {
	if o == nil || len(*o) == 0 {
		return nil
	}

	slice := PassengerSlice{}
	var args []interface{}
	for _, obj := range *o {
		pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), passengerPrimaryKeyMapping)
		args = append(args, pkeyArgs...)
	}

	sql := "SELECT `passenger`.* FROM `passenger` WHERE " +
		strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), 0, passengerPrimaryKeyColumns, len(*o))

	q := queries.Raw(sql, args...)

	err := q.Bind(ctx, exec, &slice)
	if err != nil {
		return errors.Wrap(err, "models: unable to reload all in PassengerSlice")
	}

	*o = slice

	return nil
}

// PassengerExists checks if the Passenger row exists.
func PassengerExists(ctx context.Context, exec boil.ContextExecutor, iD int) (bool, error) {
	var exists bool
	sql := "select exists(select 1 from `passenger` where `id`=? limit 1)"

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, sql)
		fmt.Fprintln(writer, iD)
	}
	row := exec.QueryRowContext(ctx, sql, iD)

	err := row.Scan(&exists)
	if err != nil {
		return false, errors.Wrap(err, "models: unable to check if passenger exists")
	}

	return exists, nil
}
